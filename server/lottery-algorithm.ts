// Lottery analysis algorithm module\n// Simplified version for phase 1 implementation\n\nexport interface ScoredNumber {\n  num: string;\n  sum: number;\n  span: number;\n  sumScore: string;\n  spanScore: string;\n  hotColdScore: string;\n  hitScore: string;\n  totalScore: string;\n  hotCount: number;\n  coldCount: number;\n  containsKeyCode: boolean;\n  isEdgeValue: boolean;\n  digits: number[];\n}\n\nexport interface AnalysisResult {\n  hotDigits: number[];\n  coldDigits: number[];\n  keyCodes: number[];\n  codeFreq: Record<number, number>;\n  scoredNumbers: Record<string, ScoredNumber>;\n  layerResults: Record<string, ScoredNumber[]>;\n}\n\n// Extract last 3 digits from 4-digit number\nexport function extractLastThreeDigits(fourDigitStr: string): string {\n  const digits = fourDigitStr.split(\",\").map((d) => d.trim());\n  if (digits.length >= 4) {\n    return digits.slice(1).join(\"\");\n  }\n  return \"\";\n}\n\n// Analyze history data to find hot/cold/key codes\nexport function analyzeHistoryData(\n  draws: Array<{ number: string }>,\n  keyCodeCount: number = 3\n): {\n  hotDigits: number[];\n  coldDigits: number[];\n  keyCodes: number[];\n  codeFreq: Record<number, number>;\n} {\n  const codeFreq: Record<number, number> = {};\n\n  draws.forEach((draw) => {\n    const digits = draw.number.split(\"\").map((d) => parseInt(d, 10));\n    digits.forEach((digit) => {\n      codeFreq[digit] = (codeFreq[digit] || 0) + 1;\n    });\n  });\n\n  const sorted = Object.entries(codeFreq)\n    .map(([digit, freq]) => ({ digit: parseInt(digit, 10), freq }))\n    .sort((a, b) => b.freq - a.freq);\n\n  const hotDigits = sorted.slice(0, 3).map((d) => d.digit);\n  const coldDigits = sorted.slice(-3).map((d) => d.digit);\n  const keyCodes = sorted.slice(0, keyCodeCount).map((d) => d.digit);\n\n  return { hotDigits, coldDigits, keyCodes, codeFreq };\n}\n\n// Calculate AI 4D scores for all numbers\nexport function calculateScores(\n  hotDigits: number[],\n  coldDigits: number[],\n  keyCodes: number[],\n  codeFreq: Record<number, number>\n): Record<string, ScoredNumber> {\n  const scoredNumbers: Record<string, ScoredNumber> = {};\n  const maxFreq = Math.max(...Object.values(codeFreq), 1);\n\n  for (let i = 0; i <= 999; i++) {\n    const num = String(i).padStart(3, \"0\");\n    const digits = num.split(\"\").map((d) => parseInt(d, 10));\n\n    // Dimension 1: Sum score\n    const sum = digits.reduce((a, b) => a + b, 0);\n    const sumScore =\n      Math.abs(sum - 16) <= 6 ? 10 - (Math.abs(sum - 16) / 6) * 5 : 2;\n\n    // Dimension 2: Span score\n    const span = Math.max(...digits) - Math.min(...digits);\n    const spanScore =\n      Math.abs(span - 5) <= 1 ? 10 - Math.abs(span - 5) * 2 : 3;\n\n    // Dimension 3: Hot/cold score\n    const hotCount = digits.filter((d) => hotDigits.includes(d)).length;\n    const coldCount = digits.filter((d) => coldDigits.includes(d)).length;\n\n    let hotColdScore = 5;\n    if (\n      (hotCount === 2 && coldCount === 1) ||\n      (hotCount === 1 && coldCount === 2)\n    ) {\n      hotColdScore = 10;\n    } else if (hotCount === 3) {\n      hotColdScore = 4;\n    } else if (coldCount === 3) {\n      hotColdScore = 3;\n    } else if (hotCount === 2 && coldCount === 0) {\n      hotColdScore = 7;\n    } else if (hotCount === 1 && coldCount === 0) {\n      hotColdScore = 6;\n    }\n\n    // Dimension 4: Hit rate score\n    const freq = codeFreq[num] || 0;\n    const hitScore = (freq / maxFreq) * 10;\n\n    // Total score\n    const totalScore = (sumScore + spanScore + hotColdScore + hitScore) / 4;\n\n    // Additional flags\n    const containsKeyCode = digits.some((d) => keyCodes.includes(d));\n    const isEdgeValue = (sum < 10 || sum > 22) || (span < 4 || span > 6);\n\n    scoredNumbers[num] = {\n      num,\n      sum,\n      span,\n      sumScore: sumScore.toFixed(2),\n      spanScore: spanScore.toFixed(2),\n      hotColdScore: hotColdScore.toFixed(2),\n      hitScore: hitScore.toFixed(2),\n      totalScore: totalScore.toFixed(2),\n      hotCount,\n      coldCount,\n      containsKeyCode,\n      isEdgeValue,\n      digits,\n    };\n  }\n\n  return scoredNumbers;\n}\n\n// Perform 9-layer filtering\nexport function performNineLayerFiltering(\n  scoredNumbers: Record<string, ScoredNumber>,\n  hotDigits: number[],\n  keyCodes: number[]\n): Record<string, ScoredNumber[]> {\n  const layerResults: Record<string, ScoredNumber[]> = {};\n\n  const allScored = Object.values(scoredNumbers).sort(\n    (a, b) => parseFloat(b.totalScore) - parseFloat(a.totalScore)\n  );\n\n  // L9: Original layer (top 90%)\n  layerResults.L9 = allScored.slice(0, 900);\n\n  // L8: Edge layer (remove bottom 20%)\n  layerResults.L8 = layerResults.L9.slice(0, 800);\n\n  // L7: Balance layer (70% hot, 20% cold, 10% other)\n  const withHot = layerResults.L8.filter((n) => n.hotCount > 0);\n  const withCold = layerResults.L8.filter((n) => n.coldCount > 0);\n  const others = layerResults.L8.filter(\n    (n) => n.hotCount === 0 && n.coldCount === 0\n  );\n  layerResults.L7 = [\n    ...withHot.slice(0, Math.floor(700 * 0.7)),\n    ...withCold.slice(0, Math.floor(700 * 0.2)),\n    ...others.slice(0, Math.floor(700 * 0.1)),\n  ].slice(0, 700);\n\n  // L6: Fault tolerance layer (600 combinations)\n  layerResults.L6 = layerResults.L7.slice(0, 600);\n\n  // L5: Standard layer (500 combinations)\n  layerResults.L5 = layerResults.L6.slice(0, 500);\n\n  // L4: Extension layer (400 combinations)\n  const edgeCombos = layerResults.L5.filter((n) => n.isEdgeValue);\n  const normalCombos = layerResults.L5.filter((n) => !n.isEdgeValue);\n  layerResults.L4 = [\n    ...edgeCombos.slice(0, Math.floor(400 * 0.4)),\n    ...normalCombos.slice(0, Math.floor(400 * 0.6)),\n  ].slice(0, 400);\n\n  // L3: Core layer (300 combinations with key codes)\n  const withKeyCode = layerResults.L4.filter((n) => n.containsKeyCode);\n  const withoutKeyCode = layerResults.L4.filter((n) => !n.containsKeyCode);\n  layerResults.L3 = [\n    ...withKeyCode.slice(0, 300),\n    ...withoutKeyCode.slice(0, Math.max(0, 300 - withKeyCode.length)),\n  ].slice(0, 300);\n\n  // L2: Selected layer (200 combinations)\n  layerResults.L2 = layerResults.L3.slice(0, 200);\n\n  // L1: Limit layer (100 combinations)\n  layerResults.L1 = layerResults.L2.slice(0, 100);\n\n  return layerResults;\n}\n\n// Test if draw number hits L6 layer\nexport function testL6Hit(\n  drawNumber: string,\n  l6Results: ScoredNumber[]\n): boolean {\n  return l6Results.some((item) => item.num === drawNumber);\n}\n\n// Get layer information\nexport const LAYERS = [\n  { id: \"L9\", name: \"Original\", ratio: 0.9, desc: \"Top 90% by score\" },\n  { id: \"L8\", name: \"Edge\", ratio: 0.8, desc: \"Remove bottom 20%\" },\n  { id: \"L7\", name: \"Balance\", ratio: 0.7, desc: \"Hot/cold distribution\" },\n  { id: \"L6\", name: \"Fault Tolerance\", ratio: 0.6, desc: \"Fault tolerance\" },\n  { id: \"L5\", name: \"Standard\", ratio: 0.5, desc: \"Standard matrix\" },\n  { id: \"L4\", name: \"Extension\", ratio: 0.4, desc: \"Range coverage\" },\n  { id: \"L3\", name: \"Core\", ratio: 0.3, desc: \"Key code rotation\" },\n  { id: \"L2\", name: \"Selected\", ratio: 0.2, desc: \"Misalignment\" },\n  { id: \"L1\", name: \"Limit\", ratio: 0.1, desc: \"Top scores only\" },\n];\n"
